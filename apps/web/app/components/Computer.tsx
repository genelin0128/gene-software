/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: NLM (https://sketchfab.com/NLM-Group)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/concept-retro-computer-free-d91ef7be56a644a79a4a607a95dc0976
Title: Concept retro computer (Free)
*/
"use client";

import React, { JSX, useEffect, useRef } from "react";
import { useGLTF, useAnimations, useVideoTexture } from "@react-three/drei";
import * as THREE from "three";

type GLTFStuff = {
    nodes: Record<string, any>;
    materials: Record<string, any>;
    animations: THREE.AnimationClip[];
};

type Props = JSX.IntrinsicElements["group"];

const Computer: React.FC<Props> = (props) => {

    const group = useRef<THREE.Group>(null!);
    const { nodes, materials } = useGLTF("/models/computer.glb") as unknown as GLTFStuff;

    const txt = useVideoTexture("projects/cardz/cardz.mp4");

    useEffect(() => {
        const geom: THREE.BufferGeometry = nodes.Cube002_Material001_0.geometry;
        const uvAttr = geom.attributes.uv as THREE.BufferAttribute | undefined;
        if (!uvAttr) return;

        let minU = Infinity, minV = Infinity, maxU = -Infinity, maxV = -Infinity;
        for (let i = 0; i < uvAttr.count; i++) {
            const u = uvAttr.getX(i);
            const v = uvAttr.getY(i);
            if (u < minU) minU = u;
            if (v < minV) minV = v;
            if (u > maxU) maxU = u;
            if (v > maxV) maxV = v;
        }
        const rangeU = maxU - minU || 1;
        const rangeV = maxV - minV || 1;

        for (let i = 0; i < uvAttr.count; i++) {
            const u = uvAttr.getX(i);
            const v = uvAttr.getY(i);
            uvAttr.setXY(i, (u - minU) / rangeU, (v - minV) / rangeV);
        }
        uvAttr.needsUpdate = true;
    }, [nodes]);

    return (
        <group {...props} dispose={null}>
            <group scale={0.01}>
                <group rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Cube_monitorbody_0.geometry}
                        material={materials.monitorbody}
                    />
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Cube_White_0.geometry}
                        material={materials.White}
                    />
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Cube_Black_0.geometry}
                        material={materials.Black}
                    />
                </group>
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube001_Material001_0.geometry}
                    material={materials["Material.001"]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Circle_monitorstand_0.geometry}
                    material={materials.monitorstand}
                    position={[0, 8.347, 0]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube002_Material001_0.geometry}
                    material={materials["Material.001"]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                >
                    <meshBasicMaterial map={txt} />
                </mesh>
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube004_Material002_0.geometry}
                    material={materials["Material.002"]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube003_Computer_0.geometry}
                    material={materials.Computer}
                    position={[208.042, 74.359, 36.73]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube005_Computer_0.geometry}
                    material={materials.Computer}
                    position={[208.042, 74.359, 36.73]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube006_Computer_0.geometry}
                    material={materials.Computer}
                    position={[208.042, 110.028, 36.73]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube007_Computer_0.geometry}
                    material={materials.Computer}
                    position={[208.042, 74.359, 36.73]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Cube008_Computer_0.geometry}
                    material={materials.Computer}
                    position={[208.042, 74.359, 36.73]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
            </group>
        </group>
    );
};

useGLTF.preload("/models/computer.glb");

export default Computer;